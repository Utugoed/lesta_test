# Тестовое задание Lesta Games

### Задание 1

Для того, чтобы сравнить скорость работы предложенного мной способа проверки четности числа и способа, приведенного в условии, я воспользовался методом dis модуля dis, кторый показал следующий результат

Предложенный мной метод:
>2 LOAD_FAST                0 (value)\
  4 LOAD_CONST               1 (1)\
  6 BINARY_OP                1 (&)\
  10 LOAD_CONST               2 (0)\
  12 COMPARE_OP              40 (==)\

Метод, предложенный в условии:
>2 LOAD_FAST                0 (value)\
  4 LOAD_CONST               1 (2)\
  6 BINARY_OP                6 (%)\
  10 LOAD_CONST               2 (0)\
  12 COMPARE_OP              40 (==)\

Таким образом количество операций, совершаемых интерпретатором python оказалось одинаковым. Чтобы проверить эффективность метода более точно, я переписал код на языке C++ и дизассемблировал его в дебаггере gdb, который показал следующий результат

Предложенный мной метод:
>0x0000000000001139 <+0>:     push   rbp\
   0x000000000000113a <+1>:     mov    rbp,rsp\
   0x000000000000113d <+4>:     mov    DWORD PTR [rbp-0x14],edi\
   0x0000000000001140 <+7>:     mov    eax,DWORD PTR [rbp-0x14]\
   0x0000000000001143 <+10>:    and    eax,0x1\
   0x0000000000001146 <+13>:    mov    DWORD PTR [rbp-0x4],eax\
   0x0000000000001149 <+16>:    cmp    DWORD PTR [rbp-0x4],0x0\
   0x000000000000114d <+20>:    sete   al\
   0x0000000000001150 <+23>:    mov    BYTE PTR [rbp-0x5],al\
   0x0000000000001153 <+26>:    movzx  eax,BYTE PTR [rbp-0x5]\
   0x0000000000001157 <+30>:    pop    rbp\
   0x0000000000001158 <+31>:    ret\

Метод, предложенный в условии:
>0x0000000000001159 <+0>:     push   rbp\
   0x000000000000115a <+1>:     mov    rbp,rsp\
   0x000000000000115d <+4>:     mov    DWORD PTR [rbp-0x14],edi\
   0x0000000000001160 <+7>:     mov    edx,DWORD PTR [rbp-0x14]\
   0x0000000000001163 <+10>:    mov    eax,edx\
   0x0000000000001165 <+12>:    sar    eax,0x1f\
   0x0000000000001168 <+15>:    shr    eax,0x1f\
   0x000000000000116b <+18>:    add    edx,eax\
   0x000000000000116d <+20>:    and    edx,0x1\
   0x0000000000001170 <+23>:    sub    edx,eax\
   0x0000000000001172 <+25>:    mov    DWORD PTR [rbp-0x4],edx\
   0x0000000000001175 <+28>:    cmp    DWORD PTR [rbp-0x4],0x0\
   0x0000000000001179 <+32>:    sete   al\
   0x000000000000117c <+35>:    mov    BYTE PTR [rbp-0x5],al\
   0x000000000000117f <+38>:    movzx  eax,BYTE PTR [rbp-0x5]\
   0x0000000000001183 <+42>:    pop    rbp\
   0x0000000000001184 <+43>:    ret\

После дизассемблирования кода, скомпилированного из C++, стало хорошо видно, что побитовая операция И занимает всего 1 инструкцию, в то время, как операция получения остатка от деления занимает 6 инструкций.

Таким образом, предложенное мной решения является более эффективным, хотя имеет недостаток в виде снижения удобочитаемости исходного кода, в то время, как вариант, предложенный в условии задачи является менее эффективным, зато более наглядным.

### Задание 2