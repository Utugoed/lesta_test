# Тестовое задание Lesta Games

### Задание 1

Для того, чтобы сравнить скорость работы предложенного мной способа проверки четности числа и способа, приведенного в условии, я воспользовался методом dis модуля dis, кторый показал следующий результат

Предложенный мной метод:
>2 LOAD_FAST                0 (value)\
  4 LOAD_CONST               1 (1)\
  6 BINARY_OP                1 (&)\
  10 LOAD_CONST               2 (0)\
  12 COMPARE_OP              40 (==)\

Метод, предложенный в условии:
>2 LOAD_FAST                0 (value)\
  4 LOAD_CONST               1 (2)\
  6 BINARY_OP                6 (%)\
  10 LOAD_CONST               2 (0)\
  12 COMPARE_OP              40 (==)\

Таким образом количество операций, совершаемых интерпретатором python оказалось одинаковым. Чтобы проверить эффективность метода более точно, я переписал код на языке C++ и дизассемблировал его в дебаггере gdb, который показал следующий результат

Предложенный мной метод:
>0x0000000000001139 <+0>:     push   rbp\
   0x000000000000113a <+1>:     mov    rbp,rsp\
   0x000000000000113d <+4>:     mov    DWORD PTR [rbp-0x14],edi\
   0x0000000000001140 <+7>:     mov    eax,DWORD PTR [rbp-0x14]\
   0x0000000000001143 <+10>:    and    eax,0x1\
   0x0000000000001146 <+13>:    mov    DWORD PTR [rbp-0x4],eax\
   0x0000000000001149 <+16>:    cmp    DWORD PTR [rbp-0x4],0x0\
   0x000000000000114d <+20>:    sete   al\
   0x0000000000001150 <+23>:    mov    BYTE PTR [rbp-0x5],al\
   0x0000000000001153 <+26>:    movzx  eax,BYTE PTR [rbp-0x5]\
   0x0000000000001157 <+30>:    pop    rbp\
   0x0000000000001158 <+31>:    ret\

Метод, предложенный в условии:
>0x0000000000001159 <+0>:     push   rbp\
   0x000000000000115a <+1>:     mov    rbp,rsp\
   0x000000000000115d <+4>:     mov    DWORD PTR [rbp-0x14],edi\
   0x0000000000001160 <+7>:     mov    edx,DWORD PTR [rbp-0x14]\
   0x0000000000001163 <+10>:    mov    eax,edx\
   0x0000000000001165 <+12>:    sar    eax,0x1f\
   0x0000000000001168 <+15>:    shr    eax,0x1f\
   0x000000000000116b <+18>:    add    edx,eax\
   0x000000000000116d <+20>:    and    edx,0x1\
   0x0000000000001170 <+23>:    sub    edx,eax\
   0x0000000000001172 <+25>:    mov    DWORD PTR [rbp-0x4],edx\
   0x0000000000001175 <+28>:    cmp    DWORD PTR [rbp-0x4],0x0\
   0x0000000000001179 <+32>:    sete   al\
   0x000000000000117c <+35>:    mov    BYTE PTR [rbp-0x5],al\
   0x000000000000117f <+38>:    movzx  eax,BYTE PTR [rbp-0x5]\
   0x0000000000001183 <+42>:    pop    rbp\
   0x0000000000001184 <+43>:    ret\

После дизассемблирования кода, скомпилированного из C++, стало хорошо видно, что побитовая операция И занимает всего 1 инструкцию, в то время, как операция получения остатка от деления занимает 6 инструкций.

Таким образом, предложенное мной решения является более эффективным, хотя имеет недостаток в виде снижения удобочитаемости исходного кода, в то время, как вариант, предложенный в условии задачи является менее эффективным, зато более наглядным.

### Задание 2

Для организации циклического буффера FIFO я создал 2 реализации. Первая сохраняет буффер в виде массива, и если при заполнении дозодит до конца массива, начинает заполнять его с начала. Вторая реализация сохраняет буффер в виде замкнутого связного списка. 

Преимуществом первой реализации является более экономное использование памяти, однако она работает медленнее, чем вторая, из-за того, что в первом случае в качестве указателя хранится индекс массива и при каждом обращении необходимо обратиться не только к атрибуту buffer, но и получить значение из массива, которым он является, тогда как во втором случае мы храним указатель на объект со значение, и нам нужна только одна операция обращения к атрибуту - получение этого значения. Также в связи с тем, что во втором случае мы храним замкнутый связный список, что позволяет избежать проверки окончаиня массива при чтении записи, то есть при каждой операции. Вторая реализация, в свою очередь, работает быстрее, но занимает больше места.

### Задание 3

В качестве наиболее быстрого способа сортировки я выбрал сортировку слиянием. Я знаю о существовании Timsort, но так как в условии задания сказано, что заимствование кода не приветствуется, я не решился выбирать его, так как до сих пор не был знаком с принципом его работы.

Сортировка слиянием является одной из двух известных мне на текущий момент реализаций сортировки, дающих в среднем случае скорость NlogN, второй является быстрая сортировка. Однако в худшем случае быстрая сортировка работает за N^2, так как каждый раз, при выборе опорной точки мы можем выбирать минимальный или максимальный элемент. Сортировка слиянием в свою очередь всегда юудет отрабатывать за NlogN
